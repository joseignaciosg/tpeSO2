Programas de prueba

camino:

Este programa implementa un algoritmo para resolver el problema del camino
con un trozo de una sola vía (igual al problema de los monitos que cruzan un 
precipicio por una cuerda en el libro de Tanenbaum).
Esta solución tiene un proceso que controla el camino; este proceso funciona
recibiendo mensajes de sensores de autos ubicados en cada mano del camino,
uno un poco antes de llegar a la zona de una vía, y otro al salir de la misma.
El proceso de control abre y cierra las barreras que dan acceso a esta zona.
Está implementado como un autómata finito, a medida que recibe mensajes
cambia de estado y ejecuta acciiones (abrir y cerrar barreras).
Cada auto se implementa mediante una tarea; la lógica del proceso auto 
consiste en examinar el camino que tiene delante, si está libre avanza, y si
no se detiene. También trata de mantener un cuadradito de distancia con el
auto que va delante. Los autos envían mensajes al proceso de control cuando
pasan por los sensores, y se terminan cuando salen del camino.
El proceso principal se queda leyendo teclas, con una I crea un auto que se
dirige hacia la izquierda, con una D uno que se dirige hacia la derecha y
con una S (salir) termina el programa.
Esta solución sufre de inanición, es decir, si hay una sucesión continua de
autos pasando hacia un lado, los que quieren ir hacia el otro lado pueden
tener que esperar eternamente.

camino1:

Igual que el anterior, pero se ha solucionado el problema de la inanición.
Ahora, si hay un flujo de autos hacia un lado y alguien quiere pasar hacia
el otro lado, se interrumpe la circulación cuando han pasado N autos en el
sentido original. El valor N se puede pasar por línea de comando, el default
es 10. Ejemplo:

			camino1 8

El cambio reside en el proceso de control, que ahora tiene más estados, y
se han debido agregar dos sensores más que están en el mismo lugar que las
barreras; estos sensores son necesarios para llevar la cuenta de cuántos
autos están en la zona de una sola vía y esperar a que salgan de ella cuando
se da vuelta el sentido de circulación; se ven cuando se abre la barrera
correspondiente.

camino2:

Igual que camino1, pero para la serialización de DOS se ha capturado la
interrupción de software de DOS. Nótese que igualmente hay funciones que
necesitan usar el mutex de DOS porque realizan ciertas operaciones que
deben ser atómicas, como colocar el cursor en la pantalla y luego imprimir.

pmath:

Prueba el guardado y restauración del contexto aritmético del procesador.
Tiene dos tareas que realizan una misma operación de punto flotante: una de
ellas lo hace en un loop continuo, y la tarea principal, que corre con mayor
prioridad, cuando lee una tecla. Como las teclas entran por interrupción,
esto provoca a menudo que la segunda tarea se vea interrumpida en el uso del 
contexto aritmético. El programa acepta dos argumentos:

	pmath n m

Si n evalúa a un número distinto de cero se protege el contexto aritmético
de la tarea principal, y si m es distinto de cero se protege el contexto
aritmético de la tarea secundaria. La combinación correcta es pmath 1 1;
pmath 1 0 produce errores rápidamente. Pmath 0 0 y pmath 0 1 no parecen
producir errores con un Pentium, aunque supongo que deberían. Hay que 
investigar un poco más esto.
Este programa termina cuando se tipea la tecla 's'.

pmon:

Prueba el módulo de monitores. Tiene dos procesos, productor y consumidor.
El productor es la tarea principal, que lee teclas y se las pasa al
consumidor mediante una variable global. El consumidor lee las teclas de 
esta variable, las imprime y borra la variable colocándola en cero. Se
utiliza un monitor con una variable de condición.

El productor ejecuta el siguiente lazo:
	- Entra al monitor
	- Mientras la variable global contiene una tecla, espera en la
	  variable de condición.
	- Lee una tecla y la deja en la variable global
	- Señaliza la variable de condición
	- Sale del monitor
	
El consumidor ejecuta el siguiente lazo:
	- Entra el monitor
	- Mientras la variable global está en cero, espera en la variable
	  de condición.
	- Imprime la variable global y la pone en cero
	- Señaliza la variable de condición.
	- Sale del monitor.

El programa termina cuando se tipea la tecls 's'.

pmsgq:

Prueba las colas de mensajes. Tiene un productor y un consumidor. El productor
es la tarea principal, que lee líneas, las transforma en un long mediante
atol() y las envía por la cola. El consumidor lee longs de la cola y los
imprime. El programa termina cuando se ingresa una línea vacía.

ppipe:

Prueba los pipes. Tiene un productor y un consumidor. El productor
es la tarea principal, que lee líneas, y las escribe en un pipe.
El consumidor lee de la cola e imprime. El programa termina cuando se tipea
una línea vacía.

psend:

Prueba el pasaje de mensajes. Tiene un productor y un consumidor. El productor
es la tarea principal, que lee líneas, y las envía como mensajes al consumidor.
El consumidor recibe los mensajes y los imprime. El programa termina cuando
se tipea una línea vacía.

filo, sfilo:

Solución del problema de los filósofos mediante un monitor. La solución más 
simple (sfilo) usa una única variable de condición, mientras que filo usa una 
por cada filósofo para no despertar filósofos innecesariamente. Ambos programas
se comportan en forma idéntica, filo es teóricamente más eficiente por eliminar
cambios de contexto innecesarios.
