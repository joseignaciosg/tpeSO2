#include "../include/kasm.h"
#include "../include/defs.h"
#include "../include/kernel.h"
#include "../include/kc.h"




DESCR_INT idt[0xA];			/* IDT de 10 entradas*/
IDTR idtr;				/* IDTR */

int tickpos=640;
KEY_BUFFER buffer; //MODIFIED

int count =100 ; //MODIFIED
char str[10]; //MODIFIED
int is=0;

void int_08() {
  
    //la int08 es la direccion correspondiente al timer tick( el taiker tick va continuamente aca a buscar que hacer)
    //char *video = (char *) 0xb8000; //es la pantalla
    //video[tickpos+=2]='*';
        
}

void int_80(int call)
{
//    _asm_("\n\t"
// 	 "\n\t"
// 	 "\n\t"
// 	 "\n\t"
// 	 "\n\t"
// 	 "\n\t");
  
  
   //MODIFIED
//      if ( call == WRITE ){ 
//        __asm__("mov ebx,1 \n\t"
//  	    "mov $4,%eax \n\t");
//      }else if ( call == READ ){
//        __asm__("mov $1,%ebx \n\t"
//  	    "mov eax,3 \n\t");
//      }
    //MODIFIED
}

//third test  
static inline //working
unsigned char inb( unsigned short port )
{
    unsigned char ret;
    asm volatile( "inb %1, %0"
                  : "=a"(ret) : "Nd"(port) );
    return ret;
}

//pendiente
void int_09() { // interrupcion que corresponde al teclado
  //leer una tecla del teclado
  //guardar en el KEY_BUFFER buffer
//   buffer.array[0] = 'h'; //test
//   buffer.array[0] = 'o';
//   buffer.array[0] = 'l';
//   buffer.array[0] = 'a';
//   buffer.next_char=4;
//   dword ret;






	asm volatile ( "pushl %eax\n\t" );//  make sure you don't damage current state 
	//unsigned char c = inb(0x60);// read information from the keyboard
	
	//char lowercase[256] = {0x1E:'a'};
	//char uppercase[256] = {0x1E:'A'};
 
 	unsigned shift_state = 0;
   //unsigned char new_scan_code = inb(0x60);
	unsigned char new_scan_code = _inport(0x60);
 	char new_char;
 	unsigned char new_code;
 	static const unsigned char tablaShift[][83] = {    {0/*Esc*/,'1','2','3','4','5','6','7','8','9',            /*de 0x1 a 0xA*/
                            '0','-','=','\b',0/*Tab*/,'q','w','e','r','t',            /*de 0xB a 0x14*/
                            'y','u','i','o','p','[',']','\n',0/*ctrl*/,'a',            /*de 0x15 a 0x1E*/
                            's','d','f','g','h','j','k','l',';','\'',            /*de 0x1F a 0x28*/
                            '`',0/*Lshift*/,'\\','z','x','c','v','b','n','m',        /*de 0x29 a 0x32*/
                            ',','.','/',0/*Rshift*/,0,0/*alt*/,' ',0/*caps*/,0,0,        /*de 0x33 a 0x3C*/
                            0,0,0,0,0,0,0,0,0,0,                        /*de 0x3D a 0x46*/
                            0,0,0,0,0,0,0,0,0,0,                        /*de 0x47 a 0x50*/
                            0,0,0},                                /*de 0x51 a 0x53*/
                            {0/*Esc*/,'!','@','#','$','%','^','&','*','(',            /*de 0x1 a 0xA*/
                            ')','_','+','\b',0,'Q','W','E','R','T',                /*de 0xB a 0x14*/
                            'Y','U','I','O','P','{','}','\n',0/*ctrl*/,'A',            /*de 0x15 a 0x1E*/
                            'S','D','F','G','H','J','K','L',':','"',            /*de 0x1F a 0x28*/
                            '~',0/*Lshift*/,'|','Z','X','C','V','B','N','M',        /*de 0x29 a 0x32*/
                            '<','>','?',0/*Rshift*/,0,0/*alt*/,' ',0/*caps*/,0,0,        /*de 0x33 a 0x3C*/
                            0,0,0,0,0,0,0,0,0,0,                        /*de 0x3D a 0x46*/
                            0,0,0,0,0,0,0,0,0,0,                        /*de 0x47 a 0x50*/
                            0,0,0}};                            /*de 0x51 a 0x53*/
    switch(new_scan_code) {
    
   
        case 0x2a: 
            shift_state = 1; 
            break;
 
        case 0xaa: 
            shift_state = 0;
            break;
 
        default:
           if (new_scan_code & 0x80) {
              /* Ignore the break code */
            //  new_code = new_scan_code & 0xF0;
				//	if ( new_scan_code == 0x1e -1 ){
					//	putc('a');			
       	       //} 
              //putc(new_scan_code);
             char c= tablaShift[0][new_scan_code-1];
             putc(c);
              
           } //else {
            //  new_char =(shift_state ? uppercase:lowercase)[new_scan_code];
              /* Do something with new_char. */
           //   putc(new_char);
          // }
           break;
     }
 
   //  outportb(0x20,0x20);
 

	
}
  





/**********************************************
kmain() 
Punto de entrada de c√≥o C.
*************************************************/

kmain() 
{

        int i,num;
	
/* Borra la pantalla. */ 

	k_clear_screen();
	
	
	
	
	
	//putc('l');
	
	//testing
 //	char s[5] = {'l','u','l','i',-1};
 //	print(s);


/* CARGA DE IDT CON LA RUTINA DE ATENCION DE IRQ0    */

        setup_IDT_entry (&idt[0x08], 0x08, (dword)&_int_08_hand, ACS_INT, 0);
	
/* Carga de IDTR    */

	idtr.base = 0;  
	idtr.base +=(dword) &idt;
	idtr.limit = sizeof(idt)-1;
	
	_lidt (&idtr);	

	_Cli();
/* Habilito interrupcion de timer tick*/




/* CARGA DE IDT CON LA INT 09  EN LA IRQ1*/

       setup_IDT_entry (&idt[0x09], 0x09, (dword)&_int_09_hand, ACS_INT, 1);
/* Carga de IDTR    */
 		//idtr.base = 1;  
 		//idtr.base +=(dword) &idt;
 		//idtr.limit = sizeof(idt)-1;
 		//_lidt (&idtr);	 
 		_Cli();
	
/* Habilito interrupcion 09*/

        _mascaraPIC1(0xFC);
        _mascaraPIC2(0xFF);
        
	_Sti();

        while(1)
        {
        }
}

